import io
import sys

_INPUT = """\
11
11111100111
512298012 821282085 543342199 868532399 690830957 973970164 928915367 954764623 923012648 540375785 925723427
"""
sys.stdin = io.StringIO(_INPUT)

#(問題)
#N
#S
#C1 C2 ... CN
#良い文字列＝ i文字目とi+1文字目が一致するようなものがちょうど1つだけ存在する
#良い文字列の例）10010
#悪い文字列の例）11011、00011
#iごとにi番目の0と1を入れ替える。ただし、Ciのコストがかかる
#最小のコストで良い文字列にする

#(方針)
#基本的には交互、1か所だけ連続する。
#1の連続する部分を見つけ、その部分を交互に変えていく
#例：00011で良い文字列にするiの組み合わせは
#1と5   →10010
#2      →01011
#3と4   →00101

#長さNの文字列Tを仮定したとき、いい文字列の組み合わせは、
#0始まりのとき連続する可能性のある個所がN-1か所
#1始まりのとき連続する可能性のある個所がN-1か所
#→最大で2(N-1)か所。Nが最大で2*10^5なので、全探索できる
#TとSの差分をとり、その差分のCを合計

#例）N=5のとき、できる良い文字列は
#00101,01101,01001,01011,11010,10010,10110,10100
#それぞれ、00011との差分は
#00101→3,4      →2+6=8
#01101→2,3,4    →9+2+6=17
#01001→2,4      →9+6=15
#01011→2        →9
#11010→1,2,5    →3+9+4=16
#10010→1,5      →3+4=7
#10110→1,3,5    →3+2+4=9
#10100→1,3,4,5  →3+2+6+4=15
#最小のコストは7

#(方針変更)
#0始まりの01交互文字列と、1始まりの10交互文字列を作成
#それとはじめからi番目、i番目から最後までのコストを計算しておく
#jを1からN-1まで動かし、j番目にj-1番目と同じ文字を挿入するていで、0はじまり、1はじまりのコストを両方計算

#############ここから下をコピペ#############

#入力
N = int(input())
S = input()
list_C = list(map(int, input().split()))

#処理
out = 10**14 * 2
#0始まりで0と1が交互になる長さN-1の文字列を作成
T0="01" * (N//2) + "0"*(N%2)
T1="10" * (N//2) + "1"*(N%2)
list_cost_0_from_i = []
list_cost_1_from_i = []

#T0,T1とSの差分をとり、その差分のCを合計
cost_0_from_i = 0
cost_1_from_i = 0
for j in range(N):
    if T0[j] != S[j]:
        cost_0_from_i += list_C[j]
    if T1[j] != S[j]:
        cost_1_from_i += list_C[j]
    list_cost_0_from_i.append(cost_0_from_i)
    list_cost_1_from_i.append(cost_1_from_i)

#2番目からN番目まで(i=1～N-1)に１つ前と同じ文字を挿入して文字列Tを作成したとき
#0始まりのときのコストはcost_0_from_i[i] + (cost_1_from_i[-1] - cost_1_from_i[i]) + list_C[i](i番目が異なる場合のみ)
#1始まりのときのコストはcost_1_from_i[i] + (cost_0_from_i[-1] - cost_0_from_i[i]) + list_C[i](i番目が異なる場合のみ)
for i in range(1, N):
    #0はじまりのコスト
    cost_0 = list_cost_0_from_i[i-1] + (list_cost_1_from_i[-1] - list_cost_1_from_i[i-1])
    #1はじまりのコスト
    cost_1 = list_cost_1_from_i[i-1] + (list_cost_0_from_i[-1] - list_cost_0_from_i[i-1])
    #i番目が異なる場合のみ
    if T0[i-1] != S[i]:
        cost_0 += list_C[i]
    else:
        cost_1 += list_C[i]
    
    out = min(out, cost_0, cost_1)

#出力
print(out)